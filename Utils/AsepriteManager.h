#ifndef GBFIGHTER_ASEPRITEMANAGER_H
#define GBFIGHTER_ASEPRITEMANAGER_H

#include "../Constants.h"
#include "../nlohmann/json.hpp"
#include "raylib.h"
#include <fstream>
#include <iostream>
#include <map>
#include <string>

struct FrameTag; // forward declaration

/* #region ---AsepriteAnimationFile class--- */

/**
 * @brief
 * @param filename Filename as a String without file-extension. The class will look for a [filename].png and [filename].json
 * @param foldername Foldername where the png and json is located
 */
class AsepriteAnimationFile
{
private:
    // member variables
    std::string filename;
    Texture2D texture;
    std::string current_tag;
    int current_frame;
    int min_frame;
    int max_frame;
    Color current_color;
    float current_scale;
    float update_counter;

    // debug member variables
    bool frameTagPrinted = false;


public:
    explicit AsepriteAnimationFile(std::string filename, std::string foldername);

    // destructor
    ~AsepriteAnimationFile();

    // methods
    FrameTag getFrameTag(const std::string& tagname);
    void drawFrame(const std::string& tagname, int x, int y, float scale = 1.0f, Color tint = WHITE);
    void drawCurrentSelectedTag(int x, int y);
    void update(float deltaTime);
    void nextFrame();
    void setFrameTag(const std::string& tagname);

    // debug-methods
    void printFrameTag(const std::string& tagname);

    // member variables
    std::map<std::string, FrameTag> frameTags;
};

/* #endregion */

/* #region ---AsepriteManager class--- */
/**
 * @class AsepriteManager
 * @brief The object instantiated of this class controlls the loading of sprites
 * @param[in] foldername where the png and json-files of the aseprite-assets are located
 */
class AsepriteManager
{
public:
    explicit AsepriteManager(std::string foldername);
    ~AsepriteManager();

    // public methods
    /**
     * @brief loads the png and json file generated by aseprite and stores it in a membervariable called animFiles, which is a map<std::string, AsepriteAnimationFile*>
     * so for example animFiles["gbFighter"] holds a AsepriteAnimationFile*.
     *
     * @param filename the filename without extension of the png and json file of aseprite. For example "gbFighter"
     */
    void loadAnimFile(const std::string& filename);

    void showLoadedAnimFiles();

    /**
     * @brief This function returns a pointer to an AnimationObject
     * @param filename filename of a .json-object without .json at the end
     * @return AnimationObject* : A pointer to an AnimationObject
     *
     * the AnimationObject has a frameTags of type maps which holds
     * frameTags["Animation Name as String"] = pair<from, to>
     */
    AsepriteAnimationFile* getAnimFile(const std::string& filename);

    void UnloadRessources();

    // public member variable
    std::map<std::string, AsepriteAnimationFile*> animFiles; // map<animationfilename><animationobject*>
private:
    // private member variable
    std::string foldername;

    // private methods
    /**
     * @brief This function reads a JsonFile, creates a nlohmann:json-object on the heap and returns a pointer to this json-object.
     * it does NOT handle the deletion of this object on the heap. this needs to be done through the code which calls the method loadJsonFile
     * an receives the pointer to the object on the heap.
     * @param filename filename of a .json-object without .json at the end
     * @return nlohmann::json* : A pointer to a json-object
     */
    nlohmann::json* loadJsonFile(const std::string& filename);
};
/* #endregion */

/* #region ---FrameTag struct--- */

struct FrameTag
{
    std::string name;
    std::string direction;
    bool loop;
    int duration;
    int from;
    int to;
};

//overrite the operator<< for FrameTag
std::ostream& operator<<(std::ostream& os, const FrameTag& frameTag);
/* #endregion */

#endif // GBFIGHTER_ASEPRITEMANAGER_H
