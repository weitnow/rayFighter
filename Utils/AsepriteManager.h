#ifndef GBFIGHTER_ASEPRITEMANAGER_H
#define GBFIGHTER_ASEPRITEMANAGER_H

#include "../Constants.h"
#include "../nlohmann/json.hpp"
#include "raylib.h"
#include <fstream>
#include <iostream>
#include <map>
#include <string>

struct FrameTag; // forward declaration

/* #region ---AsepriteAnimationFile class--- */

/**
 * @brief the class holds a reference to the texture (png file) and will have a map called frameTags.
 * frameTags["gbFighter"] holds for example the FrameTag-Object (with direction, loop, duration and from and to, where from is the first anim-area of
 * in the texture and to is the last anim-area in the texture)
 * @param filename filename withouth extensions. the class will look for a json and a png file. both needs to be present.
 * @param foldername the folder in which the png and json file is located
 */
class AsepriteTextureAndJsonContainer
{
private:
    std::string filename;
    Texture2D texture;
    std::map<std::string, FrameTag> frameTags;

public:
    AsepriteTextureAndJsonContainer(std::string filename, std::string foldername);
    ~AsepriteTextureAndJsonContainer();
};

/**
 * @brief currently holds filename "gbfighter", and its texture, as well as a frameTags<string, FrameTag>
 * @param filename Filename as a String without file-extension. The class will look for a [filename].png and [filename].json
 * @param foldername Foldername where the png and json is located
 */
class AsepriteAnimationFile
{
private:
    // member variables
    std::string filename;
    Texture2D texture; // todo: Move this out in a new class
    std::string current_tag;
    int current_frame;
    int min_frame;
    int max_frame;
    Color current_color;
    float current_scale;
    float update_counter;

    // debug member variables
    bool frameTagPrinted = false; // used by the printFrameTag-method.
                                  //This method prints out debug informatin and changes frameTagPrinted to True

public:
    explicit AsepriteAnimationFile(std::string filename, std::string foldername);

    // destructor
    ~AsepriteAnimationFile();

    // methods
    /**
     * @brief Get the Frame Tag object. The object hast a name (for example "Idle"), a from, a to, a loop and a duration property. The number in "from"
     * is the position of the starting picture, the number in "to" is the last picture of the animation. After the last picture, the first picture (from)
     * hast to be played again.
     * @param tagname
     * @return FrameTag
     */
    FrameTag getFrameTag(const std::string& tagname);
    void drawFrame(const std::string& tagname, int x, int y, float scale = 1.0f, Color tint = WHITE);
    void drawCurrentSelectedTag(int x, int y);

    /**
     * @brief the update methode calls frequently the nextFrame() which switches to the next picture of the animation
     *
     * @param deltaTime
     */
    void update(float deltaTime);

    /**
     * @brief checks if the current_frame < max_frame and if so, switches to the next frame otherwise it goes back to the first frame of the animation
     *
     */
    void nextFrame();
    void setFrameTag(const std::string& tagname);

    // debug-methods
    /**
     * @brief prints the tagname (for example Idle), the direction (for example forward), Loop (for example no), Duration, from and to
     *
     * @param tagname the name of the tag (for example "Idle") of the given AsepriteAnimationFile (for example "GbFighter")
     */
    void printFrameTag(const std::string& tagname);

    // member variables
    std::map<std::string, FrameTag> frameTags; // todo: Move this out in a new class
};

/* #endregion */

/* #region ---AsepriteManager class--- */
/**
 * @class AsepriteManager
 * @brief The object instantiated of this class controlls the loading of sprites
 * @param[in] foldername where the png and json-files of the aseprite-assets are located
 */
class AsepriteManager
{
public:
    explicit AsepriteManager(std::string foldername);
    ~AsepriteManager();

    // public methods
    /**
     * @brief loads the png and json file generated by aseprite and stores it in a membervariable called animFiles, which is a map<std::string, AsepriteAnimationFile*>
     * so for example animFiles["gbFighter"] holds a AsepriteAnimationFile*.
     *
     * The methode UnloadRessources deletes all AsepriteAnimationFile-Objects on the heap.
     *
     * The AsepriteAnimationFile currently holds not only the texture
     *
     * @param filename the filename without extension of the png and json file of aseprite. For example "gbFighter"
     */
    void loadAnimFile(const std::string& filename);

    void showLoadedAnimFiles();

    /**
     * @brief This function returns a pointer to an AnimationObject
     * @param filename filename of a .json-object without .json at the end
     * @return AnimationObject* : A pointer to an AnimationObject
     *
     * the AnimationObject has a frameTags of type maps which holds
     * frameTags["Animation Name as String"] = pair<from, to>
     */
    AsepriteAnimationFile* getAnimFile(const std::string& filename);

    /**
     * @brief This Methodes loops through all objects in the member variable animFiles and calls the destructor of the AsepriteAnimationFile*,
     * then frees the Memory on the heap and set the string (pair first of the map) = nullptr.
     */
    void UnloadRessources();

    // public member variable
    std::map<std::string, AsepriteAnimationFile*> animFiles;

private:
    // private member variable
    std::string foldername;

    // private methods
    /**
     * @brief This function reads a JsonFile, creates a nlohmann:json-object on the heap and returns a pointer to this json-object.
     * it does NOT handle the deletion of this object on the heap. this needs to be done through the code which calls the method loadJsonFile
     * an receives the pointer to the object on the heap.
     * @param filename filename of a .json-object without .json at the end
     * @return nlohmann::json* : A pointer to a json-object
     */
    nlohmann::json* loadJsonFile(const std::string& filename);
};
/* #endregion */

/* #region ---FrameTag struct--- */

struct FrameTag
{
    std::string name;
    std::string direction;
    bool loop;
    int duration;
    int from;
    int to;
};

//overrite the operator<< for FrameTag
std::ostream& operator<<(std::ostream& os, const FrameTag& frameTag);
/* #endregion */

#endif // GBFIGHTER_ASEPRITEMANAGER_H
